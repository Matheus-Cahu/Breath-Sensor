#include <ESP8266WiFi.h>
#include <ESP8266HTTPClient.h>
#include <WiFiManager.h>
#include <EEPROM.h>

extern "C" {
  #include "user_interface.h"
}

const int ledPin = D1;
const int botaoPin = D2;
const int resetWiFiPin = D3;

unsigned long tempoUltimoEnvioEstado = 0;

// Vari√°veis de debounce - L√ìGICA CORRIGIDA
bool botaoAtualmentePressionado = false;  // Estado l√≥gico do bot√£o (true = pressionado)
bool botaoEstadoAnterior = false;         // Estado anterior para detectar mudan√ßas
bool leituraAnterior = HIGH;              // √öltima leitura do pino (HIGH = solto com pull-up)
unsigned long tempoUltimaMudanca = 0;
unsigned long tempoInicializacao = 0;
bool sistemaEstabilizado = false;
const unsigned long tempoDebounce = 50;
const unsigned long tempoEstabilizacao = 2000; // 2 segundos para estabilizar

String serverEstadoUrl;

IPAddress provisionerIp;
bool provisionerIpEncontrado = false;

// --- FUN√á√ïES DE EEPROM PARA IP DO PROVISIONADOR ---

#define EEPROM_SIZE 20
#define EEPROM_ADDR_IP 0

void salvaProvisionerIp(IPAddress ip) {
  String ipStr = ip.toString();
  int len = ipStr.length();
  EEPROM.write(EEPROM_ADDR_IP, len);
  for (int i = 0; i < len; i++) {
    EEPROM.write(EEPROM_ADDR_IP + 1 + i, ipStr[i]);
  }
  EEPROM.commit();
  Serial.println("IP do provisionador salvo na EEPROM: " + ipStr);
}

bool carregaProvisionerIp(IPAddress &ip) {
  int len = EEPROM.read(EEPROM_ADDR_IP);
  if (len <= 0 || len > 15) return false;
  char ipBuffer[16];
  for (int i = 0; i < len; i++) {
    ipBuffer[i] = EEPROM.read(EEPROM_ADDR_IP + 1 + i);
  }
  ipBuffer[len] = '\0';
  ip.fromString(String(ipBuffer));
  Serial.println("IP do provisionador carregado da EEPROM: " + ip.toString());
  return true;
}

bool testarConexaoServidor(IPAddress ip) {
  WiFiClient client;
  HTTPClient http;
  
  String testUrl = "http://" + ip.toString() + ":5000/aviso?ativo=false";
  
  http.begin(client, testUrl);
  http.addHeader("User-Agent", "ESP8266");
  http.setTimeout(3000);
  
  int httpCode = http.GET();
  http.end();
  
  Serial.println("Teste " + ip.toString() + ": HTTP " + String(httpCode));
  
  return (httpCode > 0 && httpCode < 600);
}

class CustomWiFiManager : public WiFiManager {
public:
  IPAddress getProvisionerIP() {
    return provisionerIP;
  }
  
  void setProvisionerIP(IPAddress ip) {
    provisionerIP = ip;
  }

private:
  IPAddress provisionerIP;
};

void setup() {
  Serial.begin(115200);
  Serial.println("\n=== INICIANDO ESP8266 ===");
  
  pinMode(ledPin, OUTPUT);
  pinMode(botaoPin, INPUT_PULLUP);
  pinMode(resetWiFiPin, INPUT_PULLUP);

  EEPROM.begin(EEPROM_SIZE);

  WiFi.mode(WIFI_STA);
  WiFi.disconnect();
  WiFi.config(0U, 0U, 0U);
  delay(1000);

  // Verifica se bot√£o de reset foi pressionado
  if (digitalRead(resetWiFiPin) == LOW) {
    Serial.println("Resetando Wi-Fi e reiniciando...");
    WiFi.disconnect(true);
    EEPROM.write(EEPROM_ADDR_IP, 0);
    EEPROM.commit();
    delay(1000);
    ESP.restart();
  }

  // Primeiro, tenta carregar IP salvo da EEPROM
  if (carregaProvisionerIp(provisionerIp)) {
    provisionerIpEncontrado = true;
    Serial.println("Usando IP do provisionador salvo: " + provisionerIp.toString());
  }

  // Configura√ß√£o do WiFiManager
  CustomWiFiManager wm;
  WiFiManagerParameter custom_server_ip("server_ip", "IP do Servidor (ex: 192.168.0.80)", "", 15);
  wm.addParameter(&custom_server_ip);
  wm.setTimeout(180);
  
  Serial.println("Iniciando processo de conex√£o Wi-Fi...");
  Serial.println("Se n√£o conectar automaticamente, o ESP criar√° um AP chamado 'ProvisionarESP'");
  
  bool res = wm.autoConnect("ProvisionarESP");
  
  if (!res) {
    Serial.println("Falha ao conectar ou configurar Wi-Fi.");
    ESP.restart();
  }
  
  // Verifica se foi fornecido um IP customizado
  String serverIpCustom = custom_server_ip.getValue();
  if (serverIpCustom.length() > 0) {
    IPAddress customIp;
    if (customIp.fromString(serverIpCustom)) {
      provisionerIp = customIp;
      provisionerIpEncontrado = true;
      salvaProvisionerIp(provisionerIp);
      Serial.println("IP do servidor configurado manualmente: " + provisionerIp.toString());
    } else {
      Serial.println("IP customizado inv√°lido: " + serverIpCustom);
    }
  }

  Serial.println("Wi-Fi conectado!");
  Serial.println("IP do ESP: " + WiFi.localIP().toString());

  // Descoberta autom√°tica de IP se necess√°rio
  if (!provisionerIpEncontrado) {
    Serial.println("IP do servidor n√£o foi configurado. Tentando descoberta autom√°tica...");
    
    IPAddress subnet = WiFi.localIP();
    uint32_t subnetInt = (uint32_t)subnet;
    subnetInt = subnetInt & 0xFFFFFF00;
    
    int ipsComuns[] = {1, 100, 101, 102, 50, 80, 200, 254};
    
    for (int i = 0; i < 8; i++) {
      IPAddress testIp = IPAddress(subnetInt | ipsComuns[i]);
      if (testIp == WiFi.localIP()) continue;
      
      Serial.println("Testando servidor em: " + testIp.toString());
      if (testarConexaoServidor(testIp)) {
        provisionerIp = testIp;
        provisionerIpEncontrado = true;
        salvaProvisionerIp(provisionerIp);
        Serial.println("Servidor encontrado automaticamente: " + provisionerIp.toString());
        break;
      }
    }
    
    if (!provisionerIpEncontrado) {
      provisionerIp = WiFi.gatewayIP();
      Serial.println("Usando gateway como fallback: " + provisionerIp.toString());
    }
  }

  serverEstadoUrl = "http://" + provisionerIp.toString() + ":5000/aviso";

  Serial.println("=== CONFIGURA√á√ÉO FINAL ===");
  Serial.println("IP do Provisionador: " + provisionerIp.toString());
  Serial.println("URL de estado: " + serverEstadoUrl);
  Serial.println("========================");

  // INICIALIZA√á√ÉO LIMPA DO BOT√ÉO
  Serial.println("\n=== INICIALIZANDO DETEC√á√ÉO DE BOT√ÉO ===");
  
  // Estado inicial: bot√£o n√£o pressionado
  botaoAtualmentePressionado = false;
  botaoEstadoAnterior = false;
  leituraAnterior = HIGH;  // Pull-up = HIGH quando solto
  sistemaEstabilizado = false;
  tempoInicializacao = millis();
  
  // LED apagado inicialmente
  digitalWrite(ledPin, LOW);
  
  Serial.println("Estado inicial: BOT√ÉO N√ÉO PRESSIONADO");
  Serial.println("Iniciando per√≠odo de estabiliza√ß√£o...");
  
  tempoUltimoEnvioEstado = millis();
}

void enviarEstadoBotao(bool botaoPressionado) {
  if (WiFi.status() == WL_CONNECTED) {
    WiFiClient client;
    HTTPClient http;

    String estadoStr = botaoPressionado ? "true" : "false";
    String url = serverEstadoUrl + "?ativo=" + estadoStr;
    Serial.println("‚Üí Enviando para servidor: " + String(botaoPressionado ? "PRESSIONADO" : "N√ÉO PRESSIONADO"));

    http.begin(client, url);
    http.addHeader("User-Agent", "ESP8266");
    http.setTimeout(5000);

    int httpCode = http.GET();

    if (httpCode > 0) {
      Serial.printf("‚úì Estado enviado com sucesso | HTTP: %d\n", httpCode);
    } else {
      Serial.printf("‚úó Falha ao enviar | Erro: %s\n", http.errorToString(httpCode).c_str());
    }
    http.end();
  } else {
    Serial.println("‚úó Wi-Fi desconectado, n√£o foi poss√≠vel enviar estado.");
  }
}

void loop() {
  // Reset WiFi se bot√£o pressionado
  if (digitalRead(resetWiFiPin) == LOW) {
    Serial.println("Bot√£o D3 pressionado: apagando credenciais e reiniciando...");
    WiFi.disconnect(true);
    EEPROM.write(EEPROM_ADDR_IP, 0);
    EEPROM.commit();
    delay(1000);
    ESP.restart();
  }

  unsigned long agora = millis();

  // Per√≠odo de estabiliza√ß√£o
  if (!sistemaEstabilizado) {
    if ((agora - tempoInicializacao) >= tempoEstabilizacao) {
      sistemaEstabilizado = true;
      
      // Primeira leitura ap√≥s estabiliza√ß√£o
      delay(100);
      bool leituraInicial = digitalRead(botaoPin);
      leituraAnterior = leituraInicial;
      
      // L√≥gica: LOW = pressionado, HIGH = solto (devido ao pull-up)
      botaoAtualmentePressionado = (leituraInicial == LOW);
      botaoEstadoAnterior = botaoAtualmentePressionado;
      
      Serial.println("‚úì Sistema estabilizado!");
      Serial.println("Estado real detectado: " + String(botaoAtualmentePressionado ? "PRESSIONADO" : "N√ÉO PRESSIONADO"));
      Serial.println("Leitura do pino: " + String(leituraInicial == HIGH ? "HIGH (solto)" : "LOW (pressionado)"));
      Serial.println("Monitoramento ativo.\n");
    } else {
      // Durante estabiliza√ß√£o, n√£o detecta mudan√ßas
      digitalWrite(ledPin, LOW);
      delay(10);
      return;
    }
  }

  // DETEC√á√ÉO DE MUDAN√áAS COM DEBOUNCE
  bool leituraAtual = digitalRead(botaoPin);
  
  // Se a leitura mudou, marca o tempo
  if (leituraAtual != leituraAnterior) {
    tempoUltimaMudanca = agora;
    Serial.println("Mudan√ßa detectada no pino: " + String(leituraAtual == HIGH ? "HIGH" : "LOW"));
  }

  // Se passou o tempo de debounce, processa a mudan√ßa
  if ((agora - tempoUltimaMudanca) > tempoDebounce) {
    // Converte leitura f√≠sica para estado l√≥gico
    bool novoEstadoBotao = (leituraAtual == LOW);  // LOW = pressionado
    
    // Se o estado l√≥gico mudou
    if (novoEstadoBotao != botaoAtualmentePressionado) {
      botaoAtualmentePressionado = novoEstadoBotao;
      
      Serial.println("========================");
      if (botaoAtualmentePressionado) {
        Serial.println("üî¥ BOT√ÉO PRESSIONADO!");
      } else {
        Serial.println("‚ö™ BOT√ÉO SOLTO!");
      }
      Serial.println("========================");
    }
  }

  leituraAnterior = leituraAtual;

  // Debug peri√≥dico
  static unsigned long ultimoDebug = 0;
  if ((agora - ultimoDebug) >= 10000) { // A cada 10 segundos
    Serial.println("üìä Estado atual: " + String(botaoAtualmentePressionado ? "PRESSIONADO" : "N√ÉO PRESSIONADO") + 
                   " | Pino: " + String(leituraAtual == HIGH ? "HIGH" : "LOW"));
    ultimoDebug = agora;
  }

  // Envia estado a cada 3 segundos
  if ((agora - tempoUltimoEnvioEstado) >= 3000) {
    enviarEstadoBotao(botaoAtualmentePressionado);
    tempoUltimoEnvioEstado = agora;
  }

  // Controle do LED
  digitalWrite(ledPin, botaoAtualmentePressionado ? HIGH : LOW);

  delay(10);
}
